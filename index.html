<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>text-interest-census</title>
    <script type="module" crossorigin>import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { useState, useRef, useEffect, useMemo, useCallback, StrictMode } from "https://unpkg.com/react@^18/umd/react.development.js";
import { createRoot } from "react-dom/client";
(function() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations)
      if (mutation.type === "childList")
        for (const node of mutation.addedNodes) node.tagName === "LINK" && node.rel === "modulepreload" && processPreload(node);
  }).observe(document, {
    childList: !0,
    subtree: !0
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    return link.integrity && (fetchOpts.integrity = link.integrity), link.referrerPolicy && (fetchOpts.referrerPolicy = link.referrerPolicy), link.crossOrigin === "use-credentials" ? fetchOpts.credentials = "include" : link.crossOrigin === "anonymous" ? fetchOpts.credentials = "omit" : fetchOpts.credentials = "same-origin", fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = !0;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */
var purify_cjs, hasRequiredPurify_cjs;
function requirePurify_cjs() {
  if (hasRequiredPurify_cjs) return purify_cjs;
  hasRequiredPurify_cjs = 1;
  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create
  } = Object, {
    apply,
    construct
  } = typeof Reflect < "u" && Reflect;
  freeze || (freeze = function(x) {
    return x;
  }), seal || (seal = function(x) {
    return x;
  }), apply || (apply = function(func, thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
      args[_key - 2] = arguments[_key];
    return func.apply(thisArg, args);
  }), construct || (construct = function(Func) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
      args[_key2 - 1] = arguments[_key2];
    return new Func(...args);
  });
  const arrayForEach = unapply(Array.prototype.forEach), arrayLastIndexOf = unapply(Array.prototype.lastIndexOf), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), arraySplice = unapply(Array.prototype.splice), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      thisArg instanceof RegExp && (thisArg.lastIndex = 0);
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
        args[_key3 - 1] = arguments[_key3];
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(Func) {
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
        args[_key4] = arguments[_key4];
      return construct(Func, args);
    };
  }
  function addToSet(set, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    setPrototypeOf && setPrototypeOf(set, null);
    let l = array.length;
    for (; l--; ) {
      let element = array[l];
      if (typeof element == "string") {
        const lcElement = transformCaseFunc(element);
        lcElement !== element && (isFrozen(array) || (array[l] = lcElement), element = lcElement);
      }
      set[element] = !0;
    }
    return set;
  }
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++)
      objectHasOwnProperty(array, index) || (array[index] = null);
    return array;
  }
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object))
      objectHasOwnProperty(object, property) && (Array.isArray(value) ? newObject[property] = cleanArray(value) : value && typeof value == "object" && value.constructor === Object ? newObject[property] = clone(value) : newObject[property] = value);
    return newObject;
  }
  function lookupGetter(object, prop) {
    for (; object !== null; ) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get)
          return unapply(desc.get);
        if (typeof desc.value == "function")
          return unapply(desc.value);
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  ), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  ), DOCTYPE_NAME = seal(/^html$/i), CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  const NODE_TYPE = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  }, getGlobal = function() {
    return typeof window > "u" ? null : window;
  }, _createTrustedTypesPolicy = function(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes != "object" || typeof trustedTypes.createPolicy != "function")
      return null;
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME) && (suffix = purifyHostElement.getAttribute(ATTR_NAME));
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + policyName + " could not be created."), null;
    }
  }, _createHooksMap = function() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify2 = (root) => createDOMPurify(root);
    if (DOMPurify2.version = "3.3.0", DOMPurify2.removed = [], !window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element)
      return DOMPurify2.isSupported = !1, DOMPurify2;
    let {
      document: document2
    } = window2;
    const originalDocument = document2, currentScript = originalDocument.currentScript, {
      DocumentFragment,
      HTMLTemplateElement,
      Node,
      Element,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser,
      trustedTypes
    } = window2, ElementPrototype = Element.prototype, cloneNode = lookupGetter(ElementPrototype, "cloneNode"), remove = lookupGetter(ElementPrototype, "remove"), getNextSibling = lookupGetter(ElementPrototype, "nextSibling"), getChildNodes = lookupGetter(ElementPrototype, "childNodes"), getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement == "function") {
      const template = document2.createElement("template");
      template.content && template.content.ownerDocument && (document2 = template.content.ownerDocument);
    }
    let trustedTypesPolicy, emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2, {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify2.isSupported = typeof entries == "function" && typeof getParentNode == "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS, ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), FORBID_TAGS = null, FORBID_ATTR = null;
    const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
      tagCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      }
    }));
    let ALLOW_ARIA_ATTR = !0, ALLOW_DATA_ATTR = !0, ALLOW_UNKNOWN_PROTOCOLS = !1, ALLOW_SELF_CLOSE_IN_ATTR = !0, SAFE_FOR_TEMPLATES = !1, SAFE_FOR_XML = !0, WHOLE_DOCUMENT = !1, SET_CONFIG = !1, FORCE_BODY = !1, RETURN_DOM = !1, RETURN_DOM_FRAGMENT = !1, RETURN_TRUSTED_TYPE = !1, SANITIZE_DOM = !0, SANITIZE_NAMED_PROPS = !1;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = !0, IN_PLACE = !1, USE_PROFILES = {}, FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE, IS_EMPTY_INPUT = !1, ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"], DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null, CONFIG = null;
    const formElement = document2.createElement("form"), isRegexOrFunction = function(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    }, _parseConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!(CONFIG && CONFIG === cfg)) {
        if ((!cfg || typeof cfg != "object") && (cfg = {}), cfg = clone(cfg), PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE, transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase, ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS, ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR, ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES, URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES, DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS, FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS, FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({}), FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({}), USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : !1, ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== !1, ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== !1, ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || !1, ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== !1, SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || !1, SAFE_FOR_XML = cfg.SAFE_FOR_XML !== !1, WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || !1, RETURN_DOM = cfg.RETURN_DOM || !1, RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || !1, RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || !1, FORCE_BODY = cfg.FORCE_BODY || !1, SANITIZE_DOM = cfg.SANITIZE_DOM !== !1, SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || !1, KEEP_CONTENT = cfg.KEEP_CONTENT !== !1, IN_PLACE = cfg.IN_PLACE || !1, IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE, MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS, HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS, CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {}, cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck), cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), SAFE_FOR_TEMPLATES && (ALLOW_DATA_ATTR = !1), RETURN_DOM_FRAGMENT && (RETURN_DOM = !0), USE_PROFILES && (ALLOWED_TAGS = addToSet({}, text), ALLOWED_ATTR = [], USE_PROFILES.html === !0 && (addToSet(ALLOWED_TAGS, html$1), addToSet(ALLOWED_ATTR, html)), USE_PROFILES.svg === !0 && (addToSet(ALLOWED_TAGS, svg$1), addToSet(ALLOWED_ATTR, svg), addToSet(ALLOWED_ATTR, xml)), USE_PROFILES.svgFilters === !0 && (addToSet(ALLOWED_TAGS, svgFilters), addToSet(ALLOWED_ATTR, svg), addToSet(ALLOWED_ATTR, xml)), USE_PROFILES.mathMl === !0 && (addToSet(ALLOWED_TAGS, mathMl$1), addToSet(ALLOWED_ATTR, mathMl), addToSet(ALLOWED_ATTR, xml))), cfg.ADD_TAGS && (typeof cfg.ADD_TAGS == "function" ? EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS : (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS && (ALLOWED_TAGS = clone(ALLOWED_TAGS)), addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc))), cfg.ADD_ATTR && (typeof cfg.ADD_ATTR == "function" ? EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR : (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR && (ALLOWED_ATTR = clone(ALLOWED_ATTR)), addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc))), cfg.ADD_URI_SAFE_ATTR && addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc), cfg.FORBID_CONTENTS && (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS && (FORBID_CONTENTS = clone(FORBID_CONTENTS)), addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc)), KEEP_CONTENT && (ALLOWED_TAGS["#text"] = !0), WHOLE_DOCUMENT && addToSet(ALLOWED_TAGS, ["html", "head", "body"]), ALLOWED_TAGS.table && (addToSet(ALLOWED_TAGS, ["tbody"]), delete FORBID_TAGS.tbody), cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY, emptyHTML = trustedTypesPolicy.createHTML("");
        } else
          trustedTypesPolicy === void 0 && (trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript)), trustedTypesPolicy !== null && typeof emptyHTML == "string" && (emptyHTML = trustedTypesPolicy.createHTML(""));
        freeze && freeze(cfg), CONFIG = cfg;
      }
    }, ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), _checkValidNamespace = function(element) {
      let parent = getParentNode(element);
      (!parent || !parent.tagName) && (parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      });
      const tagName = stringToLowerCase(element.tagName), parentTagName = stringToLowerCase(parent.tagName);
      return ALLOWED_NAMESPACES[element.namespaceURI] ? element.namespaceURI === SVG_NAMESPACE ? parent.namespaceURI === HTML_NAMESPACE ? tagName === "svg" : parent.namespaceURI === MATHML_NAMESPACE ? tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) : !!ALL_SVG_TAGS[tagName] : element.namespaceURI === MATHML_NAMESPACE ? parent.namespaceURI === HTML_NAMESPACE ? tagName === "math" : parent.namespaceURI === SVG_NAMESPACE ? tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName] : !!ALL_MATHML_TAGS[tagName] : element.namespaceURI === HTML_NAMESPACE ? parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName] || parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName] ? !1 : !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]) : !!(PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) : !1;
    }, _forceRemove = function(node) {
      arrayPush(DOMPurify2.removed, {
        element: node
      });
      try {
        getParentNode(node).removeChild(node);
      } catch {
        remove(node);
      }
    }, _removeAttribute = function(name, element) {
      try {
        arrayPush(DOMPurify2.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch {
        arrayPush(DOMPurify2.removed, {
          attribute: null,
          from: element
        });
      }
      if (element.removeAttribute(name), name === "is")
        if (RETURN_DOM || RETURN_DOM_FRAGMENT)
          try {
            _forceRemove(element);
          } catch {
          }
        else
          try {
            element.setAttribute(name, "");
          } catch {
          }
    }, _initDocument = function(dirty) {
      let doc = null, leadingWhitespace = null;
      if (FORCE_BODY)
        dirty = "<remove></remove>" + dirty;
      else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE && (dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>");
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE)
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch {
        }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch {
        }
      }
      const body = doc.body || doc.documentElement;
      return dirty && leadingWhitespace && body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null), NAMESPACE === HTML_NAMESPACE ? getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0] : WHOLE_DOCUMENT ? doc.documentElement : body;
    }, _createNodeIterator = function(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    }, _isClobbered = function(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName != "string" || typeof element.textContent != "string" || typeof element.removeChild != "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute != "function" || typeof element.setAttribute != "function" || typeof element.namespaceURI != "string" || typeof element.insertBefore != "function" || typeof element.hasChildNodes != "function");
    }, _isNode = function(value) {
      return typeof Node == "function" && value instanceof Node;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify2, currentNode, data, CONFIG);
      });
    }
    const _sanitizeElements = function(currentNode) {
      let content = null;
      if (_executeHooks(hooks.beforeSanitizeElements, currentNode, null), _isClobbered(currentNode))
        return _forceRemove(currentNode), !0;
      const tagName = transformCaseFunc(currentNode.nodeName);
      if (_executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      }), SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent) || currentNode.nodeType === NODE_TYPE.progressingInstruction || SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data))
        return _forceRemove(currentNode), !0;
      if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)))
          return !1;
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode, childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              const childClone = cloneNode(childNodes[i], !0);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1, parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        return _forceRemove(currentNode), !0;
      }
      return currentNode instanceof Element && !_checkValidNamespace(currentNode) || (tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML) ? (_forceRemove(currentNode), !0) : (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text && (content = currentNode.textContent, arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      }), currentNode.textContent !== content && (arrayPush(DOMPurify2.removed, {
        element: currentNode.cloneNode()
      }), currentNode.textContent = content)), _executeHooks(hooks.afterSanitizeElements, currentNode, null), !1);
    }, _isValidAttribute = function(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement))
        return !1;
      if (!(ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName))) {
        if (!(ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName))) {
          if (!(EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag))) {
            if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(_isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
              ) return !1;
            } else if (!URI_SAFE_ATTRIBUTES[lcName]) {
              if (!regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) {
                if (!((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])) {
                  if (!(ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, "")))) {
                    if (value)
                      return !1;
                  }
                }
              }
            }
          }
        }
      }
      return !0;
    }, _isBasicCustomElement = function(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    }, _sanitizeAttributes = function(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode))
        return;
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l = attributes.length;
      for (; l--; ) {
        const attr = attributes[l], {
          name,
          namespaceURI,
          value: attrValue
        } = attr, lcName = transformCaseFunc(name), initValue = attrValue;
        let value = name === "value" ? initValue : stringTrim(initValue);
        if (hookEvent.attrName = lcName, hookEvent.attrValue = value, hookEvent.keepAttr = !0, hookEvent.forceKeepAttr = void 0, _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent), value = hookEvent.attrValue, SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name") && (_removeAttribute(name, currentNode), value = SANITIZE_NAMED_PROPS_PREFIX + value), SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (lcName === "attributename" && stringMatch(value, "href")) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr)
          continue;
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        SAFE_FOR_TEMPLATES && arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes == "object" && typeof trustedTypes.getAttributeType == "function" && !namespaceURI)
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        if (value !== initValue)
          try {
            namespaceURI ? currentNode.setAttributeNS(namespaceURI, name, value) : currentNode.setAttribute(name, value), _isClobbered(currentNode) ? _forceRemove(currentNode) : arrayPop(DOMPurify2.removed);
          } catch {
            _removeAttribute(name, currentNode);
          }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    }, _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      for (_executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null); shadowNode = shadowIterator.nextNode(); )
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null), _sanitizeElements(shadowNode), _sanitizeAttributes(shadowNode), shadowNode.content instanceof DocumentFragment && _sanitizeShadowDOM2(shadowNode.content);
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    return DOMPurify2.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, body = null, importedNode = null, currentNode = null, returnNode = null;
      if (IS_EMPTY_INPUT = !dirty, IS_EMPTY_INPUT && (dirty = "\x3C!-->"), typeof dirty != "string" && !_isNode(dirty))
        if (typeof dirty.toString == "function") {
          if (dirty = dirty.toString(), typeof dirty != "string")
            throw typeErrorCreate("dirty is not a string, aborting");
        } else
          throw typeErrorCreate("toString is not a function");
      if (!DOMPurify2.isSupported)
        return dirty;
      if (SET_CONFIG || _parseConfig(cfg), DOMPurify2.removed = [], typeof dirty == "string" && (IN_PLACE = !1), IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (dirty instanceof Node)
        body = _initDocument("\x3C!---->"), importedNode = body.ownerDocument.importNode(dirty, !0), importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY" || importedNode.nodeName === "HTML" ? body = importedNode : body.appendChild(importedNode);
      else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1)
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (body = _initDocument(dirty), !body)
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
      body && FORCE_BODY && _forceRemove(body.firstChild);
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      for (; currentNode = nodeIterator.nextNode(); )
        _sanitizeElements(currentNode), _sanitizeAttributes(currentNode), currentNode.content instanceof DocumentFragment && _sanitizeShadowDOM(currentNode.content);
      if (IN_PLACE)
        return dirty;
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT)
          for (returnNode = createDocumentFragment.call(body.ownerDocument); body.firstChild; )
            returnNode.appendChild(body.firstChild);
        else
          returnNode = body;
        return (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) && (returnNode = importNode.call(originalDocument, returnNode, !0)), returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      return WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name) && (serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + `>
` + serializedHTML), SAFE_FOR_TEMPLATES && arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      }), trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    }, DOMPurify2.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg), SET_CONFIG = !0;
    }, DOMPurify2.clearConfig = function() {
      CONFIG = null, SET_CONFIG = !1;
    }, DOMPurify2.isValidAttribute = function(tag, attr, value) {
      CONFIG || _parseConfig({});
      const lcTag = transformCaseFunc(tag), lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    }, DOMPurify2.addHook = function(entryPoint, hookFunction) {
      typeof hookFunction == "function" && arrayPush(hooks[entryPoint], hookFunction);
    }, DOMPurify2.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    }, DOMPurify2.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    }, DOMPurify2.removeAllHooks = function() {
      hooks = _createHooksMap();
    }, DOMPurify2;
  }
  var purify = createDOMPurify();
  return purify_cjs = purify, purify_cjs;
}
var browser, hasRequiredBrowser;
function requireBrowser() {
  return hasRequiredBrowser || (hasRequiredBrowser = 1, browser = window.DOMPurify || (window.DOMPurify = requirePurify_cjs().default || requirePurify_cjs())), browser;
}
var browserExports = requireBrowser();
const DOMPurify = /* @__PURE__ */ getDefaultExportFromCjs(browserExports), fragsToHtml = (frags) => {
  if (frags.length == 0) return "";
  const sortedFrags = [...frags].sort((a, b) => a.year - b.year), parts = [];
  let i = 0;
  const len = sortedFrags.length;
  for (; i < len; ) {
    const startFrag = sortedFrags[i];
    let j = i;
    for (; j + 1 < len && sortedFrags[j + 1].year === sortedFrags[j].year + 1 && sortedFrags[j + 1].isBold === startFrag.isBold && sortedFrags[j + 1].isItalic === startFrag.isItalic; )
      j++;
    const endYear = sortedFrags[j].year;
    let wrapped = i === j ? `${startFrag.year}` : `${startFrag.year}-${endYear}`;
    startFrag.isItalic && (wrapped = `<i>${wrapped}</i>`), startFrag.isBold && (wrapped = `<b>${wrapped}</b>`), parts.push(wrapped), i = j + 1;
  }
  return parts.join(", ");
}, DateBlock = ({ initialValue, registerNewDates }) => {
  const [isEditing, setIsEditing] = useState(!1), [storedValue, setStoredValue] = useState(initialValue), [newValue, setNewValue] = useState(initialValue), editingRef = useRef(null), setAndSanitizeStoredValue = (unsanitizedHTML) => {
    const clean = DOMPurify.sanitize(
      unsanitizedHTML,
      {
        ALLOWED_TAGS: ["b", "i"],
        ALLOWED_ATTR: []
      }
    ), dateFrags = htmlToFrags(clean);
    console.log(dateFrags), registerNewDates?.(dateFrags);
    const reextracted = fragsToHtml(dateFrags);
    setStoredValue(reextracted);
  }, htmlToFrags = (str) => {
    const results = [];
    let isBold = !1, isItalic = !1;
    const regex = /(<b>)|(<\/b>)|(<i>)|(<\/i>)|(\d{4})(\-(\d{4}))?/g;
    let match;
    for (; (match = regex.exec(str)) !== null; )
      if (console.log(match), match[1])
        isBold = !0;
      else if (match[2])
        isBold = !1;
      else if (match[3])
        isItalic = !0;
      else if (match[4])
        isItalic = !1;
      else if (match[5] && match[6]) {
        const startYear = parseInt(match[5]);
        if (startYear < 1970 || startYear > (/* @__PURE__ */ new Date()).getFullYear() + 2)
          continue;
        const endYear = parseInt(match[7]);
        if (endYear < 1970 || endYear > (/* @__PURE__ */ new Date()).getFullYear() + 2)
          continue;
        for (let year = startYear; year <= endYear; year++)
          results.push({
            year,
            isBold,
            isItalic
          });
      } else if (match[5]) {
        const year = parseInt(match[5]);
        if (year < 1970 || year > (/* @__PURE__ */ new Date()).getFullYear() + 2)
          continue;
        results.push({
          year,
          isBold,
          isItalic
        });
      }
    return results;
  }, handleSave = () => {
    newValue.trim() === "" ? setAndSanitizeStoredValue(storedValue) : setAndSanitizeStoredValue(newValue), setIsEditing(!1);
  }, handleKeyDown = (e) => {
    e.key === "Enter" ? handleSave() : e.key === "Escape" && (setAndSanitizeStoredValue(storedValue), setIsEditing(!1));
  };
  return useEffect(() => {
    isEditing && editingRef?.current && (editingRef.current.innerHTML = storedValue);
  }, [isEditing]), isEditing ? /* @__PURE__ */ jsx(
    "div",
    {
      contentEditable: "true",
      autoFocus: !0,
      suppressContentEditableWarning: !0,
      ref: editingRef,
      onInput: (e) => setNewValue(e.currentTarget.innerHTML),
      onBlur: handleSave,
      onKeyDown: handleKeyDown
    }
  ) : /* @__PURE__ */ jsx(
    "div",
    {
      onClick: () => setIsEditing(!0),
      dangerouslySetInnerHTML: { __html: storedValue == "" ? "-" : storedValue }
    }
  );
}, EditableLabel = ({ initialValue, onSave }) => {
  const [isEditing, setIsEditing] = useState(!1), [value, setValue] = useState(initialValue), inputRef = useRef(null);
  useEffect(() => {
    isEditing && (inputRef.current?.focus(), inputRef.current?.select());
  }, [isEditing]);
  const handleSave = () => {
    value.trim() === "" ? setValue(initialValue) : onSave(value), setIsEditing(!1);
  }, handleKeyDown = (e) => {
    e.key === "Enter" ? handleSave() : e.key === "Escape" && (setValue(initialValue), setIsEditing(!1));
  };
  return isEditing ? /* @__PURE__ */ jsx(
    "input",
    {
      ref: inputRef,
      type: "text",
      value,
      onChange: (e) => setValue(e.target.value),
      onBlur: handleSave,
      onKeyDown: handleKeyDown
    }
  ) : /* @__PURE__ */ jsx(
    "div",
    {
      onClick: () => setIsEditing(!0),
      children: /* @__PURE__ */ jsx("span", { className: "", children: value })
    }
  );
}, colorMap = {
  0: "#FFFFFF",
  1: "#BBBBDD",
  2: "#8888BB",
  3: "#444499"
}, getColor = (interestStrength) => interestStrength == null ? "#FFFFFF" : colorMap[interestStrength], App = () => {
  const [rows, setRows] = useState([
    { id: crypto.randomUUID(), label: "Label 1" },
    { id: crypto.randomUUID(), label: "Label 2" }
  ]), [columns, setColumns] = useState([
    { id: "2023", label: "2023" },
    { id: "2024", label: "2024" }
  ]), [rowDateProps, setRowDateProps] = useState([]), colorState = useMemo(() => {
    const newState = {};
    return rowDateProps.forEach((rowDateProp) => {
      rowDateProp.props.forEach((dateFragProp) => {
        newState[`${rowDateProp.label}_${dateFragProp.year}`] = dateFragProp.isBold ? 3 : dateFragProp.isItalic ? 1 : 2;
      });
    }), newState;
  }, [columns, rows, rowDateProps]), handleAddRow = useCallback(() => {
    const newRow = {
      id: crypto.randomUUID(),
      label: "New Label"
    };
    setRows((prevRows) => [...prevRows, newRow]);
  }, []), handleRemoveRow = useCallback((rowId) => {
    setRows((prevRows) => prevRows.filter((row) => row.id !== rowId));
  }, []), handleUpdateRowLabel = useCallback((rowId, newLabel) => {
    console.log("saving label: " + newLabel), setRows((prevRows) => prevRows.map((row) => row.id === rowId ? { ...row, label: newLabel } : row));
  }, []), updateColumns = useCallback((newProps) => {
    newProps.length != 0 && setColumns((previousColumns) => {
      const oldMin = previousColumns.map((col) => parseInt(col.id)).reduce((x, y) => x < y ? x : y), oldMax = previousColumns.map((col) => parseInt(col.id)).reduce((x, y) => x < y ? y : x), fragMin = newProps.map((prop) => prop.year).reduce((x, y) => x < y ? x : y), fragMax = newProps.map((prop) => prop.year).reduce((x, y) => x < y ? y : x), newLeft = fragMin < oldMin ? [...Array(oldMin - fragMin).keys()].map((i) => ({ id: String(i + fragMin), label: String(i + fragMin) })) : [], newRight = fragMax > oldMax ? [...Array(fragMax - oldMax).keys()].map((i) => ({ id: String(i + oldMax + 1), label: String(i + oldMax + 1) })) : [];
      return console.log("newLeft: "), console.log(newLeft), console.log("newRight: "), console.log(newRight), [...newLeft, ...previousColumns, ...newRight];
    });
  }, []), registerFrags = useCallback((rowLabel, newProps) => {
    updateColumns(newProps);
    let rowLabelFound = !1;
    const newRowDateProps = rowDateProps.map(
      (row) => row.label == rowLabel ? (rowLabelFound = !0, { label: rowLabel, props: newProps }) : row
    );
    rowLabelFound || newRowDateProps.push({ label: rowLabel, props: newProps }), setRowDateProps(newRowDateProps);
  }, [rowDateProps]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("h1", { children: "Text Interest Census" }),
    /* @__PURE__ */ jsxs("table", { children: [
      /* @__PURE__ */ jsx("thead", { children: /* @__PURE__ */ jsxs("tr", { children: [
        /* @__PURE__ */ jsx("th", { children: "header" }),
        /* @__PURE__ */ jsx("th", {}),
        columns.map((col) => /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx("div", { style: { transform: "rotate(-70deg)", width: "10px" }, children: col.id.substring(2, 4) }) }, col.id))
      ] }) }),
      /* @__PURE__ */ jsxs("tbody", { children: [
        rows.map((row) => /* @__PURE__ */ jsxs("tr", { children: [
          /* @__PURE__ */ jsxs("td", { style: { display: "flex" }, children: [
            /* @__PURE__ */ jsx(
              EditableLabel,
              {
                initialValue: row.label,
                onSave: (newLabel) => handleUpdateRowLabel(row.id, newLabel)
              }
            ),
            /* @__PURE__ */ jsx(
              "button",
              {
                onClick: () => handleRemoveRow(row.id),
                "aria-label": `Remove row ${row.label}`,
                className: "remove-row-btn",
                children: "X"
              }
            )
          ] }),
          /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx("div", { style: { width: "200px" }, children: /* @__PURE__ */ jsx(
            DateBlock,
            {
              initialValue: "2025",
              registerNewDates: (dateFragProps) => registerFrags(row.id, dateFragProps)
            }
          ) }) }),
          columns.map((col) => /* @__PURE__ */ jsx(
            "td",
            {
              style: {
                width: "fit-content",
                backgroundColor: getColor(colorState[`${row.id}_${col.id}`])
              }
            },
            col.id
          ))
        ] }, row.id)),
        /* @__PURE__ */ jsx("tr", { children: /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx("button", { onClick: handleAddRow, children: "Add Row" }) }) })
      ] })
    ] })
  ] });
};
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsx(StrictMode, { children: /* @__PURE__ */ jsx(App, {}) })
);</script>
    <style rel="stylesheet" crossorigin>:root {
  font-family:
    system-ui,
    Avenir,
    Helvetica,
    Arial,
    sans-serif;
  line-height: 1.5;
  font-weight: 400;
  color-scheme: light dark;
  color: #ffffffde;
  background-color: #242424;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}
body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}
h1 {
  font-size: 3.2em;
  line-height: 1.1;
}
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: .6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color .25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}
@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #fff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}
.remove-row-btn {
  padding: 2px 6px;
  font-size: 12px;
  width: 28px;
  height: 24px;
  line-height: 20px;
  border-radius: 4px;
  cursor: pointer;
}
.remove-row-btn:hover {
  filter: brightness(.95);
}</style>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
